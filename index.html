<!doctype html>
<html>
	<head>
		<title>IPC Data</title>
		<script src="https://cdn.jsdelivr.net/npm/vega@5.29.0"></script>
		<script src="https://cdn.jsdelivr.net/npm/vega-lite@5.19.0"></script>
		<script src="https://cdn.jsdelivr.net/npm/vega-embed@6.25.0"></script>

		<script src="web/components/timeline.js"></script>
		<script src="web/components/histo.js"></script>
		<script src="web/components/boxplot.js"></script>
		<script src="web/components/hardirq_bar.js"></script>
		<script src="web/components/softirq_bar.js"></script>
		<script src="web/components/pkt_bar.js"></script>
		<script src="web/components/napi_graph.js"></script>
		<script src="web/components/scatterplot.js"></script>
			</head>
	<body>


		<h1>Data: <span id="datadir">None</span></h1>

		<!-- Input field -->
		<input type="text" id="myInput" placeholder="Enter text">

		<!-- Button to get input value -->
		<button onclick="getValue()">Get Value</button>

		<div id="ipc_t"></div>
		<div id="ipc_scat1"></div>
		<div id="ipc_scat2"></div>
		<div id="ipc_scat3"></div>
		<div id="ipc_histo"></div>
		<div id="ipc_box"></div>
		<div id="pkt_bar"></div>
		<div id="sirq_bar"></div>
		<div id="hirq_bar"></div>
		<div id="napi_graph"></div>

	<script type="text/javascript">

			var base_path = "data/exp_under_sparse/"

		var ds = document.getElementById("datadir");
		console.log(ds.innerHTML)

		function getValue() { 
			// Get the input element by its ID
			let inputField = document.getElementById("myInput");

			// Get the value of the input field
			let value = inputField.value;

			document.getElementById("datadir").innerHTML = value;
			
			loadAllGraphs("data/".concat(value).concat("/"))

		}



function fetchJSONData(path, divs, graphs) {
	fetch(path)
		.then((res) => {
			if (!res.ok) {
				throw new Error
				(`HTTP error! Status: ${res.status}`);
			}
			return res.json();
		})
		.then((data) =>
			{
			divs.forEach((div, idx) => {

			vegaEmbed(div, graphs[idx]).then(res =>
				res.view
				.insert('myData', data 
				).resize()
				.run()
			)
			}
);



				})
			.catch((error) =>
				console.error("Unable to fetch data:", error));
}

function loadAllGraphs(path){

var Inst_Cyc_Scatter1 = {

	"title": "IPC of different Kernel Functions",
	"width": 1000,
	"height": 1000,
	"data": {
	"name":"myData"
	},
	"transform": [
		{"calculate": "datum.Inst / datum.Cyc", "as": "IPC"},
		{"filter": "datum.IPC < 5"},
		{"filter": "datum.Cyc < 16000000000000000000"},
		{"filter":"datum.Symbol == 'net_rx_action'"},
		{"extent": "Cyc", "param": "MaxCyc"},
		{"extent": "Inst", "param": "MaxInst"}
	],
	"layer":[
		{
			"mark": "point",
			"transform": [
				{"calculate": "datum.Inst / datum.Cyc", "as": "IPC"},
				{"filter": "datum.IPC < 5"},
				{"filter": "datum.Cyc < 16000000000000000000"},

				{
					"filter":"datum.Symbol == 'net_rx_action'"
				},
			],
			"encoding": {
				"x": {"field": "Cyc", "type": "quantitative"},
				"y": {"field": "Inst", "type": "quantitative"},
				"color": {"field": "CPU", "type": "nominal"},
				"shape": {"field": "CPU", "type": "nominal"},
				"row": {"field": "Symbol"}
			}
		},

		{
			"mark": {"type": "rule", "strokeDash": [3, 1]},
			"encoding": {

				"x": {"value": {"expr": "scale('x', 0)"}},
				"y": {"value": {"expr": "scale('y', 0)"}},
				"x2": {"value": {"expr": "scale('x', (MaxCyc[1] > MaxInst[1]) ? MaxInst[1] : MaxCyc[1])"}},
				"y2": {"value": {"expr": "scale('y', (MaxCyc[1] > MaxInst[1]) ? MaxInst[1] : MaxCyc[1])"}}
			}
},
	{
		"mark": "rule",
		"encoding": {
			"y": {
				"aggregate": "mean",
				"field": "Inst",
				"type": "quantitative"
			},
			"color": {"value": "red"},
		}
	},
	{
		"mark": "rule",
		"encoding": {
			"x": {
				"aggregate": "mean",
				"field": "Cyc",
				"type": "quantitative"
			},
			"color": {"value": "red"},
		}
	}
	]

}
var Inst_Cyc_Scatter2 = {

	"title": "IPC of different Kernel Functions",
	"width": 400,
	"height": 400,
	"data": {
	"name":"myData"
	},
	"transform": [
		{"calculate": "datum.Inst / datum.Cyc", "as": "IPC"},
		{"filter": "datum.IPC < 5"},
		{"filter": "datum.Cyc < 16000000000000000000"},
		{"filter":"datum.Symbol == 'napi_gro_receive'"},
		{"extent": "Cyc", "param": "MaxCyc"},
		{"extent": "Inst", "param": "MaxInst"}
	],
	"layer":[
		{
			"mark": "point",
			"transform": [
				{"calculate": "datum.Inst / datum.Cyc", "as": "IPC"},
				{"filter": "datum.IPC < 5"},

				{
					"filter":"datum.Symbol == 'napi_gro_receive'"
				},
				{"filter": "datum.Cyc < 16000000000000000000"}
			],
			"encoding": {
				"x": {"field": "Cyc", "type": "quantitative"},
				"y": {"field": "Inst", "type": "quantitative"},
				"color": {"field": "CPU", "type": "nominal"},
				"shape": {"field": "CPU", "type": "nominal"},
				"row": {"field": "Symbol"}
			}
		},

		{
			"mark": {"type": "rule", "strokeDash": [3, 1]},
			"encoding": {

				"x": {"value": {"expr": "scale('x', 0)"}},
				"y": {"value": {"expr": "scale('y', 0)"}},
				"x2": {"value": {"expr": "scale('x', (MaxCyc[1] > MaxInst[1]) ? MaxInst[1] : MaxCyc[1])"}},
				"y2": {"value": {"expr": "scale('y', (MaxCyc[1] > MaxInst[1]) ? MaxInst[1] : MaxCyc[1])"}}
			}
		},
	{
		"mark": "rule",
		"encoding": {
			"y": {
				"aggregate": "mean",
				"field": "Inst",
				"type": "quantitative"
			},
			"color": {"value": "red"},
		}
	},
	{
		"mark": "rule",
		"encoding": {
			"x": {
				"aggregate": "mean",
				"field": "Cyc",
				"type": "quantitative"
			},
			"color": {"value": "red"},
		}
	}
	]

}
var Inst_Cyc_Scatter3 = {

	"title": "IPC of different Kernel Functions",
	"width": 400,
	"height": 400,
	"data": {
	"name":"myData"
	},
	"transform": [
		{"calculate": "datum.Inst / datum.Cyc", "as": "IPC"},
		{"filter": "datum.IPC < 5"},
		{"filter": "datum.Cyc < 16000000000000000000"},
		{"filter":"datum.Symbol == '__netif_receive_skb_list_core'"},
		{"extent": "Cyc", "param": "MaxCyc"},
		{"extent": "Inst", "param": "MaxInst"}
	],
	"layer":[
		{
			"mark": "point",
			"transform": [
			],
			"encoding": {
				"x": {"field": "Cyc", "type": "quantitative"},
				"y": {"field": "Inst", "type": "quantitative"},
				"color": {"field": "CPU", "type": "nominal"},
				"shape": {"field": "CPU", "type": "nominal"},
				"row": {"field": "Symbol"}
			}
		},

		{
			"mark": {"type": "rule", "strokeDash": [3, 1]},
			"encoding": {

				"x": {"value": {"expr": "scale('x', 0)"}},
				"y": {"value": {"expr": "scale('y', 0)"}},
				"x2": {"value": {"expr": "scale('x', (MaxCyc[1] > MaxInst[1]) ? MaxInst[1] : MaxCyc[1])"}},
				"y2": {"value": {"expr": "scale('y', (MaxCyc[1] > MaxInst[1]) ? MaxInst[1] : MaxCyc[1])"}}
			}
		},
	{
		"mark": "rule",
		"encoding": {
			"y": {
				"aggregate": "mean",
				"field": "Inst",
				"type": "quantitative"
			},
			"color": {"value": "red"},
		}
	},
	{
		"mark": "rule",
		"encoding": {
			"x": {
				"aggregate": "mean",
				"field": "Cyc",
				"type": "quantitative"
			},
			"color": {"value": "red"},
		}
	}
	]

}
	fetchJSONData(path.concat("data.json"), ['#ipc_t', '#ipc_histo', '#ipc_box', '#ipc_scat1', '#ipc_scat2', '#ipc_scat3'], [IPC_Time, IPC_Histo, IPC_Box, Inst_Cyc_Scatter1, Inst_Cyc_Scatter2, Inst_Cyc_Scatter3])
	fetchJSONData(path.concat("packet_cnt.json"), ['#pkt_bar'], [pkt_bar])
	fetchJSONData(path.concat("softirq.json"), ['#sirq_bar'], [sirq_bar])
	fetchJSONData(path.concat("irq.json"), ['#hirq_bar'], [hirq_bar])
	fetchJSONData(path.concat("iperf.json"), ['#napi_graph'], [napi_graph])

}


		</script>
	</body>
</html>

